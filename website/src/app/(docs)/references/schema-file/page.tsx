import Link from "next/link";
import { Highlight } from "@/app/_utils/Highlight";
import { Toc } from "../../_toc";
import { Breadcrumb } from "@/app/_utils/Breadcrumb";
import { ogp } from "@/app/_utils/metadata";
import { Hint } from "@/app/_utils/Hint";

export const metadata = ogp({
  title: "Schema file reference",
});

export default function SchemaFile() {
  return (
    <Toc>
      <main>
        <Breadcrumb
          parents={[{ label: "References", href: "/references" }]}
          current="Schema file reference"
        />
        <h2>Schema file reference</h2>
        <p>
          The <b>schema type definition file</b> is used to express your GraphQL
          schema as TypeScript types. It is generated by the{" "}
          <code>nitrogql generate</code> command and written to the path
          specified by the{" "}
          <Link href="/configuration/options#generate.schemaOutput">
            <code>generate.schemaOutput</code>
          </Link>{" "}
          option.
        </p>
        <p>
          This file is depended by other files generated by nitrogql. Also, you
          might want to import it in your own code to use the generated types.
        </p>

        <h3 id="exported-types">Exported Types</h3>
        <p>
          The schema type definition file exports a TypeScript type for each
          GraphQL type defined in your schema ( scalar, object, interface,
          union, enum, and input object) with the same name.
        </p>
        <p>
          Note that the types define here basically correspond to the result of
          GraphQL operations. Therefore, it is not suited for use by server-side
          code. See{" "}
          <Link href="/reference/resolver-file">
            Resolvers type file reference
          </Link>{" "}
          for the types usable by server-side code.
        </p>
        <h4 id="scalar-types">Scalar Types</h4>
        <p>
          TypeScript type for a scalar type is determined by the{" "}
          <Link href="/configuration/options#generate.type.scalarTypes">
            <code>generate.type.scalarTypes</code>
          </Link>{" "}
          option.
        </p>
        <h4 id="object-types">Object Types</h4>
        <p>
          TypeScript type for an object type is an object type. It has a
          property for each field of the object type. Fields with nullable
          GraphQL type are also nullable (<code>| null</code>) in TypeScript.
          Note that nullable fields are not optional (<code>field?: ...</code>)
          in TypeScript.
        </p>
        <p>
          Note that the exported types also have the <code>__typename</code>{" "}
          field.
        </p>

        <h4 id="interface-types">Interface Types and Union Types</h4>
        <p>
          TypeScript type for an interface type or a union type is a union type
          of object types that implement the interface or are included in the
          union.
        </p>
        <h4 id="enum-types">Enum Types</h4>
        <p>
          TypeScript type for an enum type is a union of string literals types
          that correspond to the enum values.
        </p>
        <p>
          By default, the type definition file only exports the type. If you
          configure the{" "}
          <Link href="/configuration/options#generate.emitSchemaRuntime">
            <code>generate.emitSchemaRuntime</code>
          </Link>{" "}
          option, it also exports a runtime representation of the enum type.
        </p>
        <h4 id="input-object-types">Input Object Types</h4>
        <p>
          TypeScript type for an input object type is an object type. Unlike
          (output) object types, nullable fields are also made optional in
          corresponding TypeScript types.
        </p>

        <h3 id="best-practices">Best Practices</h3>
        <p>
          Except for the runtime representation of enum types (if you like), you
          rarely need to import from this file directly. Particularly, it is not
          a good idea to use types defined in this file for internal data
          structures. Instead, you should use manually written types for
          internal data structures.
        </p>
        <Highlight language="typescript">
          {`// ‚ùå Don't do this
import { User } from "@your-org/schema-package";
export const ShowUser: React.FC<{
  user: User;
}> = ({ user }) => {
  // ...
};

// ‚úÖ Do this
export const ShowUser: React.FC<{
  user: {
    id: string;
    name: string;
  };
}> = ({ user }) => {
  // ...
};
`}
        </Highlight>
        <Hint>
          üí° This may change after a Fragment Colocation support has been
          implemented, though I am not quite convinced that Fragment Colocation
          is a good idea.
        </Hint>
      </main>
    </Toc>
  );
}
