import Link from "next/link";
import { Highlight } from "@/app/_utils/Highlight";
import { Toc } from "../../_toc";
import { Breadcrumb } from "@/app/_utils/Breadcrumb";
import { ogp } from "@/app/_utils/metadata";
import { Hint } from "@/app/_utils/Hint";

export const metadata = ogp({
  title: "Resolvers file reference",
});

export default function ResolversFile() {
  return (
    <Toc>
      <main>
        <Breadcrumb
          parents={[{ label: "References", href: "/references" }]}
          current="Resolvers file reference"
        />
        <h2>Resolvers file reference</h2>
        <p>
          The <b>resolvers type definition file</b> expresses the types of
          resolvers you need to implement a GraphQL server. It is generated by
          the <code>nitrogql generate</code> command and written to the path
          specified by the{" "}
          <Link href="/configuration/options#generate.resolversOutput">
            <code>generate.resolversOutput</code>
          </Link>{" "}
          option.
        </p>

        <h3 id="exported-types">Exported Types</h3>

        <h4 id="resolvers">Resolvers</h4>
        <p>
          <code>Resolvers&lt;Context&gt;</code> is the type of all resolvers.
          Usually, a GraphQL server accepts an object of this type as its
          <code>resolvers</code> option.
        </p>
        <p>
          <code>Context</code> is the type of the context object passed to
          resolvers.
        </p>
        <p>Example usage:</p>
        <Highlight language="typescript">
          {`import { Resolvers } from "./generated/resolvers";

type Context = {};
const resolvers: Resolvers<Context> = {
  // resolvers for top-level queries and mutations
  Query: { /* ... */ },
  Mutation: { /* ... */ },
  // resolvers for types
  User: { /* ... */ },
};`}
        </Highlight>
        <p>
          Resolver types for individual types are not exported directly.
          Instead, you can use some TypeScript trick to retrieve them.
        </p>
        <Highlight language="typescript">
          {`import { Resolvers } from "./generated/resolvers";
const queryResolvers: Resolvers<Context>["Query"] = { /* ... */ };`}
        </Highlight>

        <h4 id="resolver-output">ResolverOutput</h4>
        <p>
          By <code>ResolverOutput&lt;T&gt;</code> we mean the TypeScript type of
          the object returned by a resolver for a GraphQL type <code>T</code>.{" "}
          <code>T</code> should be a string literal type that is the name of a
          GraphQL type.
        </p>
        <p>
          In other words, it is the <i>model type</i> of <code>T</code>; see{" "}
          <Link href="/references/plugin-model">
            <code>nitrogql:model</code> plugin references
          </Link>{" "}
          for more details about the idea of model types.
        </p>
        <Highlight language="typescript">
          {`import { Resolvers, ResolverOutput } from "./generated/resolvers";

type Context = {};
const queryResolvers: Resolvers<Context>["Query"] = {
  /** get the current user */
  me: () => {
    // the type of the returned object is ResolverOutput<"User">
    return {
      id: "1",
      name: "John Doe",
    };
  }
};
const userResolvers: Resolvers<{}>["User"] = {
  email: async (user) => {
    // the type of \`user\` is ResolverOutput<"User">
    const email = await getEmail(user.id);
  }
}`}
        </Highlight>
        <p>
          <code>ResolverOutput</code> is useful when you want to give a name to
          the type of an object that should be returned by a resolver.
        </p>
      </main>
    </Toc>
  );
}
